#include <knitro.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "opt.h"
#include "fcn.h"
#include "pre.h"

#ifndef MICROSEC
#  define MICROSEC 1000000
#endif

#undef epsilon
#define epsilon 1.0e-10

/*****************************************************************************/
/* These functions are for obtaining the compacted vertex representation     */
/* of the mesh and for putting the compacted vectex representation back into */
/* the mesh structure.                                                       */
/*****************************************************************************/

static void scatterMesh(Mesh *m, const double *src) 
{
  /***************************************************************************/
  /* Take the src vertices and apply the inverse permutation to scatter the  */
  /* nonfixed coordinates into the mesh structure.                           */
  /***************************************************************************/

  double *v = m->v;
  int    *ip = m->i;

  const int nn = m->nn;
  int     i, loc;

  for (i = 0; i < nn; ++i) {
    loc = *ip++;
    v[loc  ] = src[0]; 
    v[loc+1] = src[1];
    v[loc+2] = src[2];
    src += 3;
  }
  return;
}

static void gatherMesh(double *dest, const Mesh *m)
{
  /***************************************************************************/
  /* Take the src vertices and apply the permutation to gather the nonfixed  */
  /* coordinates into the dest.                                              */
  /***************************************************************************/

  double *v = m->v;
  int    *ip = m->i;

  const int nn = m->nn;
  int     i, loc;

  for (i = 0; i < nn; ++i) {
    loc = *ip++;
    dest[0] = v[loc  ]; 
    dest[1] = v[loc+1];
    dest[2] = v[loc+2];
    dest += 3;
  }
  return;
}

/*****************************************************************************/
/* We now get into the code to the algorithm.  The first is a matrix vector  */
/* multiplication using the block structure.  This is in the reduced space.  */
/* We use pointer arithmetic to speed up the code generated by gcc.  Other   */
/* compilers would have done this automatically.                             */
/*****************************************************************************/

static void matmul(double *w, const Mesh *mesh, const double *p)
{
  int    *len = mesh->len;
  int    *col = mesh->col;
  double *dat = mesh->dat;
  double *n;
  double *o;

  double x[3];
  double y[3];
  double m[3];

  const int nn = mesh->nn;
  int c;
  int i, j, l;

  for (i = 0; i < nn; ++i) {
    /* Get x components and modification for diagonal block */
    l = *len++;
    c = *col++;
    o = w + c;

    x[0] = p[c];
    x[1] = p[c+1];
    x[2] = p[c+2];

    m[0] = dat[0]*x[0] + dat[1]*x[1] + dat[2]*x[2];
    m[1] = dat[1]*x[0] + dat[3]*x[1] + dat[4]*x[2];
    m[2] = dat[2]*x[0] + dat[4]*x[1] + dat[5]*x[2];
    dat += 6;

    /* Calculate the off diagonal blocks */
    for (j = 1; j < l; ++j) {
      c = *col++;
      n = w + c;
     
      y[0] = p[c];
      y[1] = p[c+1];
      y[2] = p[c+2];

      m[0] += dat[0]*y[0] + dat[1]*y[1] + dat[2]*y[2];
      m[1] += dat[3]*y[0] + dat[4]*y[1] + dat[5]*y[2];
      m[2] += dat[6]*y[0] + dat[7]*y[1] + dat[8]*y[2];

      n[0] += dat[0]*x[0] + dat[3]*x[1] + dat[6]*x[2];
      n[1] += dat[1]*x[0] + dat[4]*x[1] + dat[7]*x[2];
      n[2] += dat[2]*x[0] + dat[5]*x[1] + dat[8]*x[2];
      dat += 9;
    }

    /* Add modifiation */
    o[0] += m[0];
    o[1] += m[1];
    o[2] += m[2];
  }
  return;
}

static void matstr(int *hrow, int *hcol, const Mesh *mesh)
{
  int    *len = mesh->len;
  int    *col = mesh->col;

  const int nn = mesh->nn;
  int c;
  int i, j, l;

  for (i = 0; i < nn; ++i) {
    /* Get x components and modification for diagonal block */
    l = *len++;
    c = *col++;

    hrow[0] = 3*i+0; hcol[0] = c+0;
    hrow[1] = 3*i+0; hcol[1] = c+1;
    hrow[2] = 3*i+0; hcol[2] = c+2;
    hrow[3] = 3*i+1; hcol[3] = c+1;
    hrow[4] = 3*i+1; hcol[4] = c+2;
    hrow[5] = 3*i+2; hcol[5] = c+2;
    hrow += 6; hcol += 6;

    /* Calculate the off diagonal blocks */
    for (j = 1; j < l; ++j) {
      c = *col++;
     
      hrow[0] = 3*i+0; hcol[0] = c+0;
      hrow[1] = 3*i+0; hcol[1] = c+1;
      hrow[2] = 3*i+0; hcol[2] = c+2;
      hrow[3] = 3*i+1; hcol[3] = c+0;
      hrow[4] = 3*i+1; hcol[4] = c+1;
      hrow[5] = 3*i+1; hcol[5] = c+2;
      hrow[6] = 3*i+2; hcol[6] = c+0;
      hrow[7] = 3*i+2; hcol[7] = c+1;
      hrow[8] = 3*i+2; hcol[8] = c+2;
      hrow += 9; hcol += 9;
    }
  }
  return;
}

static double norm(const double *g, const int nn)
{
  double norm_r = 0;
  int    i;
     
  for (i = 0; i < nn; ++i) {
    norm_r += g[0]*g[0] + g[1]*g[1] + g[2]*g[2];
    g += 3;
  }
  return norm_r;
}

static double inner(const double *g, const double *w, const int nn)
{
  double inner_r = 0;
  int    i;
     
  for (i = 0; i < nn; ++i) {
    inner_r += g[0]*w[0] + g[1]*w[1] + g[2]*w[2];
    g += 3;
    w += 3;
  }
  return inner_r;
}

static void negate(double *r, const double *g, const int nn)
{
  int i;

  for (i = 0; i < nn; ++i) {
    r[0] = -g[0];
    r[1] = -g[1];
    r[2] = -g[2];
    r += 3;
    g += 3;
  }
  return;
}

static void axpy(double *r, const double *x, const double c, const double *y, 
		 const int nn)
{
  int i;

  for (i = 0; i < nn; ++i) {
    r[0] = x[0] + c*y[0];
    r[1] = x[1] + c*y[1];
    r[2] = x[2] + c*y[2];
    r += 3;
    x += 3;
    y += 3;
  }
  return;
}

static void maxpy(double *r, const double *x, const double c, const double *y, 
		  const int nn)
{
  int i;

  for (i = 0; i < nn; ++i) {
    r[0] = c*y[0] - x[0];
    r[1] = c*y[1] - x[1];
    r[2] = c*y[2] - x[2];
    r += 3;
    x += 3;
    y += 3;
  }
  return;
}

int optMesh(Mesh *mesh, int max_iter, double cn_tol, int precond)
{
  /* Calls KNITRO 4.0 to solve the unconstrained optimization problem */

  KTR_context *kc;

  const int nn = mesh->nn;

  double *x, *xl, *xu;		/* Current point */
  double *lambda;		/* Lagrange multipliers */
  int    *hrow, *hcol;		/* Hessian structure */
  double obj, objn;		/* Objective function values */

  int i, status, ferr;

  int nvar;
  int ncon;
  int nnzj;
  int nnzh;

  if (nn <= 0) {
    /* No nodes!  Just return. */
    return 0;
  }

  hMesh(mesh);
  if (gFcn(&obj, mesh)) {
    fprintf(stderr, "Invalid starting point.\n");
    exit(-1);
  }

  kc = KTR_new(0);

  nvar = 3*nn;
  ncon = 0;
  nnzj = 0;
  nnzh = mesh->nz;

  x = (double *)malloc(nvar*sizeof(double));
  xl = (double *)malloc(nvar*sizeof(double));
  xu = (double *)malloc(nvar*sizeof(double));
  lambda = (double *)malloc(nvar*sizeof(double));
  hrow = (int *)malloc(nnzh*sizeof(int));
  hcol = (int *)malloc(nnzh*sizeof(int));

  gatherMesh(x, mesh);
  for (i = 0; i < 3*nn; ++i) {
    xl[i] = -KTR_INFBOUND;
    xu[i] =  KTR_INFBOUND;
    lambda[i] = 0;
  }

  matstr(hrow, hcol, mesh);

  status = KTR_RC_INITIAL;
  KTR_set_int_param(kc, KTR_PARAM_ALG, KTR_ALG_IPCG);
  KTR_set_int_param(kc, KTR_PARAM_OUTLEV, KTR_OUTLEV_MAJORIT);
  KTR_set_int_param(kc, KTR_PARAM_HESSOPT, KTR_HESSOPT_EXACT);

  do {
    scatterMesh(mesh, x);

    switch(status) {
    case KTR_RC_EVALX0:
      /* This has already been done; no need to do it again. */
      break;

    case KTR_RC_EVALFC:
      ferr = oFcn(&obj, mesh);
      if (ferr) {
	obj = KTR_INFBOUND;
      }
      break;

    case KTR_RC_EVALGA:
      gFcn(&objn, mesh);
      break;

    case KTR_RC_EVALH:
      hOnly(mesh);
      break;
    }

    status = KTR_solve(kc, &obj, 0, 
		       nvar, x, xl, xu, mesh->g, 
		       ncon, NULL, NULL, NULL, NULL,
		       nnzj, NULL, NULL, NULL, lambda,
		       nnzh, mesh->dat, hrow, hcol, NULL, NULL);
  } while (status > 0);

  scatterMesh(mesh, x);

  KTR_free(&kc);

  free(x);
  free(xl);
  free(xu);
  free(lambda);
  free(hrow);
  free(hcol);
  return 0;
}
